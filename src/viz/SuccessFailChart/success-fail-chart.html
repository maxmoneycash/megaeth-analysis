<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MegaETH Successful vs. Failed Transactions</title>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.0.0/dist/pixi.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0f;
      color: #e0e0e0;
      overflow: hidden;
    }

    #container {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #header {
      padding: 20px 40px;
      background: rgba(15, 15, 25, 0.8);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    #title {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 10px;
      color: #00ff88;
      letter-spacing: -0.5px;
    }

    #subtitle {
      font-size: 14px;
      color: #888;
      margin-bottom: 15px;
    }

    #view-controls {
      display: flex;
      gap: 10px;
    }

    .view-btn {
      padding: 8px 20px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #aaa;
      cursor: pointer;
      border-radius: 6px;
      font-size: 13px;
      font-family: inherit;
      transition: all 0.2s;
    }

    .view-btn:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(0, 255, 136, 0.3);
    }

    .view-btn.active {
      background: rgba(0, 255, 136, 0.1);
      border-color: #00ff88;
      color: #00ff88;
    }

    #canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: #0a0a0f;
    }

    #canvas-container canvas {
      display: block;
    }

    #tooltip {
      position: absolute;
      background: rgba(10, 10, 20, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.3);
      border-radius: 8px;
      padding: 12px 16px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(15px);
      font-size: 13px;
    }

    #tooltip.visible {
      opacity: 1;
    }

    .tooltip-date {
      font-weight: 600;
      margin-bottom: 8px;
      color: #00ff88;
    }

    .tooltip-row {
      display: flex;
      align-items: center;
      margin: 4px 0;
    }

    .tooltip-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .tooltip-label {
      flex: 1;
      color: #888;
    }

    .tooltip-value {
      font-weight: 600;
      color: #e0e0e0;
      margin-left: 12px;
    }

    .tooltip-row.highlighted {
      background: rgba(0, 255, 136, 0.1);
      margin-left: -8px;
      margin-right: -8px;
      padding: 4px 8px;
      border-radius: 4px;
    }

    .tooltip-row.highlighted .tooltip-value {
      font-size: 15px;
      color: #00ff88;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 16px;
      color: #00ff88;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="header">
      <div id="title">Transaction Success Rate</div>
      <div id="subtitle">Real-time tracking of successful and failed transactions on MegaETH</div>
      <div id="view-controls">
        <button class="view-btn active" data-view="daily">Daily</button>
        <button class="view-btn" data-view="weekly">Weekly</button>
        <button class="view-btn" data-view="monthly">Monthly</button>
        <button class="view-btn" data-view="all">All</button>
      </div>
    </div>

    <div id="canvas-container">
      <div id="loading">Loading data...</div>
      <div id="tooltip">
        <div class="tooltip-date" id="tooltip-date"></div>
        <div class="tooltip-row" id="failed-row">
          <div class="tooltip-dot" style="background: #ff4444;"></div>
          <div class="tooltip-label">Failed</div>
          <div class="tooltip-value" id="failed-percent">-</div>
        </div>
        <div class="tooltip-row" id="success-row">
          <div class="tooltip-dot" style="background: #44aa44;"></div>
          <div class="tooltip-label">Successful</div>
          <div class="tooltip-value" id="success-percent">-</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const API_BASE = 'http://localhost:3001';
    const FRONTIER_DATE = new Date('2025-12-18T00:00:00Z');

    let app, currentView = 'daily', chartData = [];
    let hoveredPoint = null;
    let hoveredArea = null; // 'success' or 'fail'

    const PADDING = { top: 40, right: 60, bottom: 60, left: 80 };

    // Initialize PixiJS application
    async function init() {
      const container = document.getElementById('canvas-container');
      const rect = container.getBoundingClientRect();

      app = new PIXI.Application();
      await app.init({
        width: rect.width,
        height: rect.height,
        backgroundColor: 0x0a0a0f,
        antialias: true,
        resolution: window.devicePixelRatio || 2,
        autoDensity: true,
      });

      container.appendChild(app.canvas);

      // View button handlers
      document.querySelectorAll('.view-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          currentView = e.target.dataset.view;
          loadAndDisplay(currentView);
        });
      });

      // Tooltip mouse tracking
      app.canvas.addEventListener('mousemove', (e) => {
        const rect = app.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        updateTooltip(mouseX, mouseY, e.clientX, e.clientY);
      });

      app.canvas.addEventListener('mouseleave', () => {
        hideTooltip();
        hoveredPoint = null;
        hoveredArea = null;
        if (chartData.length > 0) {
          drawChart(chartData);
        }
      });

      // Load initial view
      await loadAndDisplay(currentView);

      // Handle window resize
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          const newWidth = container.clientWidth;
          const newHeight = container.clientHeight;
          app.renderer.resize(newWidth, newHeight);
          if (chartData.length > 0) {
            drawChart(chartData);
          }
        }, 250);
      });
    }

    async function fetchTxData(view) {
      try {
        const response = await fetch(`${API_BASE}/api/tx-success-rate?view=${view}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Fetch error:', error);
        return generateMockData(view);
      }
    }

    function generateMockData(view) {
      const now = new Date();
      const data = [];

      let periods, getTimestamp, getLabel;

      switch (view) {
        case 'daily':
          periods = 30; // 30 days
          getTimestamp = (i) => {
            const d = new Date(Math.max(FRONTIER_DATE.getTime(), now.getTime() - (periods - 1 - i) * 24 * 3600 * 1000));
            return d;
          };
          getLabel = (d) => d.toISOString().split('T')[0];
          break;

        case 'weekly':
          periods = 12; // 12 weeks
          getTimestamp = (i) => {
            const d = new Date(Math.max(FRONTIER_DATE.getTime(), now.getTime() - (periods - 1 - i) * 7 * 24 * 3600 * 1000));
            return d;
          };
          getLabel = (d) => d.toISOString().split('T')[0];
          break;

        case 'monthly':
          periods = 12; // 12 months
          getTimestamp = (i) => {
            const d = new Date(now);
            d.setMonth(d.getMonth() - (periods - 1 - i));
            d.setDate(1);
            return new Date(Math.max(FRONTIER_DATE.getTime(), d.getTime()));
          };
          getLabel = (d) => d.toISOString().split('T')[0];
          break;

        case 'all':
          // From Frontier to now
          const daysSinceFrontier = Math.floor((now - FRONTIER_DATE) / (24 * 3600 * 1000));
          periods = Math.min(daysSinceFrontier, 365); // Cap at 365 days for performance
          getTimestamp = (i) => {
            const d = new Date(FRONTIER_DATE.getTime() + i * (daysSinceFrontier / periods) * 24 * 3600 * 1000);
            return d;
          };
          getLabel = (d) => d.toISOString().split('T')[0];
          break;
      }

      for (let i = 0; i < periods; i++) {
        const timestamp = getTimestamp(i);
        // Generate realistic success rate (90-98%)
        const successRate = 0.90 + Math.random() * 0.08;
        const failRate = 1 - successRate;

        data.push({
          timestamp: timestamp.toISOString(),
          label: getLabel(timestamp),
          success_percent: successRate * 100,
          fail_percent: failRate * 100,
        });
      }

      return data;
    }

    function drawChart(data) {
      if (!app) return;

      app.stage.removeChildren();

      const width = app.renderer.width;
      const height = app.renderer.height;

      const chartWidth = width - PADDING.left - PADDING.right;
      const chartHeight = height - PADDING.top - PADDING.bottom;

      // Calculate point positions
      const points = data.map((d, i) => {
        const x = PADDING.left + (i * chartWidth / Math.max(data.length - 1, 1));
        const successHeight = (d.success_percent / 100) * chartHeight;
        const failHeight = (d.fail_percent / 100) * chartHeight;

        return {
          x,
          ySuccess: PADDING.top + chartHeight - successHeight,
          yFail: PADDING.top + chartHeight - successHeight - failHeight,
          data: d
        };
      });

      // Create graphics
      const successArea = new PIXI.Graphics();
      const failArea = new PIXI.Graphics();
      const gridGraphics = new PIXI.Graphics();
      const axisGraphics = new PIXI.Graphics();
      const hoverLine = new PIXI.Graphics();

      // Draw grid lines (horizontal - percentage lines)
      for (let i = 0; i <= 4; i++) {
        const y = PADDING.top + (i * chartHeight / 4);
        gridGraphics.moveTo(PADDING.left, y);
        gridGraphics.lineTo(PADDING.left + chartWidth, y);
        gridGraphics.stroke({ width: 1, color: 0x222222, alpha: 0.3 });

        // Y-axis labels (percentages)
        const percent = 100 - (i * 25);
        const text = new PIXI.Text({
          text: `${percent}%`,
          style: {
            fontFamily: 'Courier New, monospace',
            fontSize: 11,
            fill: 0x888888,
            align: 'right'
          }
        });
        text.x = PADDING.left - 10;
        text.y = y;
        text.anchor.set(1, 0.5);
        app.stage.addChild(text);
      }

      // Draw success area (green) - bottom area
      if (points.length > 0) {
        successArea.moveTo(points[0].x, PADDING.top + chartHeight);
        successArea.lineTo(points[0].x, points[0].ySuccess);

        for (let i = 1; i < points.length; i++) {
          successArea.lineTo(points[i].x, points[i].ySuccess);
        }

        successArea.lineTo(points[points.length - 1].x, PADDING.top + chartHeight);
        successArea.closePath();

        // Dim if hovering over fail area
        const successAlpha = (hoveredArea === 'fail') ? 0.3 : 0.9;
        successArea.fill({ color: 0x44aa44, alpha: successAlpha });
      }

      // Draw fail area (red) - top area
      if (points.length > 0) {
        failArea.moveTo(points[0].x, points[0].ySuccess);
        failArea.lineTo(points[0].x, points[0].yFail);

        for (let i = 1; i < points.length; i++) {
          failArea.lineTo(points[i].x, points[i].yFail);
        }

        for (let i = points.length - 1; i >= 0; i--) {
          failArea.lineTo(points[i].x, points[i].ySuccess);
        }

        failArea.closePath();

        // Dim if hovering over success area
        const failAlpha = (hoveredArea === 'success') ? 0.3 : 0.9;
        failArea.fill({ color: 0xff4444, alpha: failAlpha });
      }

      // Draw axes
      axisGraphics.moveTo(PADDING.left, PADDING.top);
      axisGraphics.lineTo(PADDING.left, PADDING.top + chartHeight);
      axisGraphics.lineTo(PADDING.left + chartWidth, PADDING.top + chartHeight);
      axisGraphics.stroke({ width: 2, color: 0x444444 });

      // X-axis labels (dates)
      const labelStep = Math.max(1, Math.floor(points.length / 8));
      points.forEach((p, i) => {
        if (i % labelStep === 0 || i === points.length - 1) {
          const date = new Date(p.data.timestamp);
          const labelText = currentView === 'all' || currentView === 'monthly'
            ? date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
            : date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

          const text = new PIXI.Text({
            text: labelText,
            style: {
              fontFamily: 'Courier New, monospace',
              fontSize: 11,
              fill: 0x888888,
              align: 'center'
            }
          });
          text.x = p.x;
          text.y = PADDING.top + chartHeight + 10;
          text.anchor.set(0.5, 0);
          app.stage.addChild(text);
        }
      });

      // Draw hover line if point is hovered
      if (hoveredPoint !== null && hoveredPoint < points.length) {
        const p = points[hoveredPoint];
        hoverLine.moveTo(p.x, PADDING.top);
        hoverLine.lineTo(p.x, PADDING.top + chartHeight);
        hoverLine.stroke({ width: 2, color: 0x00ff88, alpha: 0.5 });
      }

      app.stage.addChild(gridGraphics);
      app.stage.addChild(successArea);
      app.stage.addChild(failArea);
      app.stage.addChild(axisGraphics);
      app.stage.addChild(hoverLine);

      // Store points for tooltip
      app.stage.points = points;
    }

    function updateTooltip(mouseX, mouseY, screenX, screenY) {
      if (!app.stage.points || app.stage.points.length === 0) return;

      const points = app.stage.points;

      // Find closest point
      let closestIdx = -1;
      let minDist = Infinity;

      points.forEach((p, i) => {
        const dist = Math.abs(p.x - mouseX);
        if (dist < minDist) {
          minDist = dist;
          closestIdx = i;
        }
      });

      if (closestIdx !== -1 && minDist < 50) {
        hoveredPoint = closestIdx;
        const point = points[closestIdx];
        const data = point.data;

        // Determine which area is being hovered (based on Y position)
        if (mouseY > point.ySuccess) {
          // Hovering over success area (bottom/green)
          hoveredArea = 'success';
        } else if (mouseY < point.ySuccess && mouseY > point.yFail) {
          // Hovering over fail area (top/red)
          hoveredArea = 'fail';
        } else {
          hoveredArea = null;
        }

        // Update tooltip content
        const date = new Date(data.timestamp);
        document.getElementById('tooltip-date').textContent =
          date.toISOString().split('T')[0] + ' ' +
          date.toTimeString().split(' ')[0].substring(0, 5);
        document.getElementById('failed-percent').textContent = data.fail_percent.toFixed(1) + '%';
        document.getElementById('success-percent').textContent = data.success_percent.toFixed(1) + '%';

        // Highlight the hovered area in tooltip
        const failRow = document.getElementById('failed-row');
        const successRow = document.getElementById('success-row');

        failRow.classList.remove('highlighted');
        successRow.classList.remove('highlighted');

        if (hoveredArea === 'fail') {
          failRow.classList.add('highlighted');
        } else if (hoveredArea === 'success') {
          successRow.classList.add('highlighted');
        }

        // Position tooltip
        const tooltip = document.getElementById('tooltip');
        tooltip.style.left = `${screenX + 15}px`;
        tooltip.style.top = `${screenY - 50}px`;
        tooltip.classList.add('visible');

        // Redraw chart with hover line and dimming
        drawChart(chartData);
      } else {
        hideTooltip();
        if (hoveredPoint !== null || hoveredArea !== null) {
          hoveredPoint = null;
          hoveredArea = null;
          drawChart(chartData);
        }
      }
    }

    function hideTooltip() {
      document.getElementById('tooltip').classList.remove('visible');
    }

    async function loadAndDisplay(view) {
      const loadingEl = document.getElementById('loading');
      loadingEl.style.display = 'block';

      try {
        chartData = await fetchTxData(view);
        drawChart(chartData);
        loadingEl.style.display = 'none';
      } catch (error) {
        console.error('Error loading chart:', error);
        loadingEl.textContent = 'Error loading data';
      }
    }

    // Start when page loads
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
