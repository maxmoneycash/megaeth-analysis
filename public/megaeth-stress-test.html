<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MegaETH Stress Test - EXPOSED (Jan 22, 2026)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow-x: hidden;
      background: #0D0D12;
      font-family: "SF Mono", "Monaco", "Inconsolata", "Fira Mono", "Droid Sans Mono", "Source Code Pro", monospace;
      color: #fff;
    }

    .main-wrapper {
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      background: #0D0D12;
    }

    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 16px;
      gap: 12px;
    }

    @media (min-width: 640px) { .container { gap: 16px; } }

    /* Chart Cards */
    .chart-card { border: 1px solid #404040; }

    .chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 16px;
      border-bottom: 1px solid #404040;
      background: #0a0a0a;
    }
    @media (min-width: 640px) { .chart-header { padding: 12px 16px; } }

    .chart-header-left { display: flex; align-items: center; gap: 12px; }

    .chart-title {
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #d4d4d4;
    }
    @media (min-width: 640px) { .chart-title { font-size: 16px; } }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      transition: background-color 0.3s;
    }
    @media (min-width: 640px) { .status-dot { width: 10px; height: 10px; } }

    .chart-value {
      font-size: 20px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }
    @media (min-width: 640px) { .chart-value { font-size: 24px; } }

    .chart-value-unit { font-size: 16px; margin-left: 2px; }

    .chart-header-right {
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 12px;
    }
    @media (min-width: 640px) { .chart-header-right { font-size: 14px; } }

    .chart-label { color: #a3a3a3; }
    .chart-label-value { color: #d4d4d4; font-weight: 600; font-variant-numeric: tabular-nums; }

    /* TPS Chart */
    .tps-chart-body { height: 208px; background: #0D0D12; }
    @media (min-width: 640px) { .tps-chart-body { height: 288px; } }
    @media (min-width: 1024px) { .tps-chart-body { height: 384px; } }

    /* Compact charts */
    .compact-chart-body { height: 176px; background: #0D0D12; }
    @media (min-width: 640px) { .compact-chart-body { height: 224px; } }
    @media (min-width: 1024px) { .compact-chart-body { height: 288px; } }

    /* Charts Grid Row */
    .charts-row { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 768px) { .charts-row { grid-template-columns: 1fr 1fr; gap: 16px; } }

    /* Block River */
    .block-river { border: 1px solid #404040; }

    .block-river-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid #404040;
      background: #0a0a0a;
    }

    .block-river-title {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #d4d4d4;
    }
    @media (min-width: 640px) { .block-river-title { font-size: 16px; } }

    /* Block River body - exact Aptos heights: h-52 sm:h-64 md:h-72 */
    .block-river-body { height: 208px; background: #0D0D12; }
    @media (min-width: 640px) { .block-river-body { height: 256px; } }
    @media (min-width: 768px) { .block-river-body { height: 288px; } }

    .block-river-footer {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 16px;
      border-top: 1px solid #404040;
      background: #0a0a0a;
    }

    .legend { display: flex; flex-wrap: wrap; align-items: center; gap: 12px; }
    @media (min-width: 640px) { .legend { gap: 20px; } }

    .legend-item { display: flex; align-items: center; gap: 8px; }

    .legend-color { width: 16px; height: 16px; }
    @media (min-width: 640px) { .legend-color { width: 20px; height: 20px; } }

    .legend-label { font-size: 12px; color: #a3a3a3; }
    @media (min-width: 640px) { .legend-label { font-size: 14px; } }

    .legend-suffix { font-size: 12px; color: #737373; }
    @media (min-width: 640px) { .legend-suffix { font-size: 14px; } }

    /* Load Tester Detection Panel */
    .spammer-panel { border: 2px solid #ff4444; background: #1a0a0a; border-radius: 8px; margin-bottom: 16px; }
    .spammer-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid #ff4444;
      background: #200a0a;
    }
    .spammer-title {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 18px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #ff6b6b;
    }
    .spammer-body { padding: 20px; }
    .spammer-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      margin-bottom: 20px;
    }
    @media (min-width: 768px) { .spammer-stats { grid-template-columns: repeat(4, 1fr); } }
    .spammer-stat {
      background: #150505;
      border: 1px solid #401010;
      border-radius: 6px;
      padding: 16px;
      text-align: center;
    }
    .spammer-stat-label { font-size: 13px; color: #999; text-transform: uppercase; margin-bottom: 8px; letter-spacing: 0.03em; }
    .spammer-stat-value { font-size: 24px; font-weight: 700; color: #ff6b6b; font-variant-numeric: tabular-nums; }
    .spammer-wallets { margin-top: 20px; }
    .spammer-wallet {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: #150505;
      border: 1px solid #301010;
      border-radius: 6px;
      margin-bottom: 8px;
      font-size: 14px;
    }
    .wallet-address { font-family: monospace; color: #ff9999; font-size: 13px; }
    .wallet-stats { display: flex; gap: 20px; color: #999; font-size: 14px; }
    .wallet-stat-value { color: #ffaaaa; font-weight: 700; }
    .spammer-note {
      margin-top: 20px;
      padding: 16px;
      background: #200a0a;
      border-left: 4px solid #ff4444;
      border-radius: 4px;
      font-size: 15px;
      color: #ccc;
      line-height: 1.6;
    }
  </style>
</head>
<body>
  <main class="main-wrapper">
    <div class="container">
      <!-- TPS Chart -->
      <div class="chart-card">
        <div class="chart-header">
          <div class="chart-header-left">
            <span class="chart-title">TPS</span>
            <span class="status-dot" id="tpsStatusDot" style="background: #404040;"></span>
            <span class="chart-value" id="tpsValue" style="color: #00ff88;">0</span>
          </div>
          <div class="chart-header-right">
            <span class="chart-label">PEAK <span class="chart-label-value" id="tpsPeak">0</span></span>
          </div>
        </div>
        <div class="tps-chart-body" id="tpsChartContainer"></div>
      </div>

      <!-- Block Time & Latency Charts Row -->
      <div class="charts-row">
        <div class="chart-card">
          <div class="chart-header">
            <div class="chart-header-left">
              <span class="chart-title">BLOCK TIME</span>
              <span class="chart-value" id="blockTimeValue" style="color: #00CEC9;">--</span>
            </div>
            <div class="chart-header-right">
              <span class="chart-label">BLOCK <span class="chart-label-value" id="blockNumber" style="color: #00d4ff;">0</span></span>
            </div>
          </div>
          <div class="compact-chart-body" id="blockTimeChartContainer"></div>
        </div>

        <div class="chart-card">
          <div class="chart-header">
            <div class="chart-header-left">
              <span class="chart-title">E2E LATENCY</span>
              <span class="status-dot" id="latencyStatusDot" style="background: #A29BFE;"></span>
              <span class="chart-value" id="latencyValue" style="color: #A29BFE;">0<span class="chart-value-unit">ms</span></span>
            </div>
            <div class="chart-header-right">
              <span class="chart-label">p50 <span class="chart-label-value" id="latencyP50">0</span></span>
              <span class="chart-label">p95 <span class="chart-label-value" id="latencyP95">0</span></span>
            </div>
          </div>
          <div class="compact-chart-body" id="latencyChartContainer"></div>
        </div>
      </div>

      <!-- Block River -->
      <div class="block-river">
        <div class="block-river-header">
          <div class="block-river-title">
            BLOCK RIVER
            <span class="status-dot" id="riverStatusDot" style="background: #404040;"></span>
          </div>
          <div class="chart-header-right">
            <span class="chart-label">LATEST <span class="chart-label-value" id="latestBlock" style="color: #00d4ff;">#0</span></span>
          </div>
        </div>
        <div class="block-river-body" id="blockRiverContainer"></div>
        <div class="block-river-footer">
          <div class="legend">
            <div class="legend-item"><div class="legend-color" style="background: #151515;"></div><span class="legend-label">0</span></div>
            <div class="legend-item"><div class="legend-color" style="background: #1f3f1f;"></div><span class="legend-label">1-50</span></div>
            <div class="legend-item"><div class="legend-color" style="background: #2d522d;"></div><span class="legend-label">50-100</span></div>
            <div class="legend-item"><div class="legend-color" style="background: #356035;"></div><span class="legend-label">100-120</span></div>
            <div class="legend-item"><div class="legend-color" style="background: #55a055;"></div><span class="legend-label">120+</span></div>
          </div>
          <span class="legend-suffix">tx per mini-block (10ms, WebSocket)</span>
        </div>
      </div>

      <!-- Compact Traffic Analysis Panel - MAINNET STRESS TEST -->
      <div id="spammerPanel" style="background: #111; border: 2px solid #ff4444; border-radius: 8px; margin-bottom: 16px;">
        <!-- Header with big status indicator -->
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; background: #1a0808; border-bottom: 2px solid #ff4444;">
          <div style="display: flex; align-items: center; gap: 16px;">
            <span style="font-size: 32px;">üö®</span>
            <div>
              <div style="font-size: 20px; font-weight: 700; color: #ff6b6b; text-transform: uppercase;">MAINNET STRESS TEST ANALYSIS</div>
              <div style="font-size: 16px; color: #aaa;" id="trafficStatusText">Monitoring synthetic vs organic traffic</div>
            </div>
          </div>
          <div style="text-align: right;">
            <div style="font-size: 48px; font-weight: 800; color: #ff4444;" id="spammerTpsPercent">99</div>
            <div style="font-size: 14px; color: #aaa; text-transform: uppercase; font-weight: 600;">% Synthetic</div>
          </div>
        </div>

        <!-- Main stats row - big numbers -->
        <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 1px; background: #333;">
          <div style="background: #151010; padding: 20px; text-align: center;">
            <div style="font-size: 36px; font-weight: 800; color: #ff6b6b;" id="loadTestTxs">0%</div>
            <div style="font-size: 14px; color: #aaa; text-transform: uppercase; margin-top: 8px; font-weight: 600;">DEX Swaps</div>
          </div>
          <div style="background: #101015; padding: 20px; text-align: center;">
            <div style="font-size: 36px; font-weight: 800; color: #aa88ff;" id="oracleTxs">0%</div>
            <div style="font-size: 14px; color: #aaa; text-transform: uppercase; margin-top: 8px; font-weight: 600;">Dust Spam</div>
          </div>
          <div style="background: #101518; padding: 20px; text-align: center;">
            <div style="font-size: 36px; font-weight: 800; color: #44ff88;" id="organicTxs">0%</div>
            <div style="font-size: 14px; color: #aaa; text-transform: uppercase; margin-top: 8px; font-weight: 600;">Organic</div>
          </div>
          <div style="background: #151008; padding: 20px; text-align: center;">
            <div style="font-size: 36px; font-weight: 800; color: #ffaa44;" id="gasUtilization">0%</div>
            <div style="font-size: 14px; color: #aaa; text-transform: uppercase; margin-top: 8px; font-weight: 600;">Gas Used</div>
          </div>
          <div style="background: #111; padding: 20px; text-align: center;">
            <div style="font-size: 24px; font-weight: 700; color: #44ff44;" id="spammerStatus">MONITORING</div>
            <div style="font-size: 14px; color: #aaa; text-transform: uppercase; margin-top: 8px; font-weight: 600;">Status</div>
          </div>
        </div>

        <!-- Two synthetic systems side by side -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; padding: 20px;">
          <!-- System 1: DEX Swaps -->
          <div style="background: #150808; border: 2px solid #401515; border-radius: 8px; padding: 16px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
              <span style="font-size: 16px; color: #ff8888; font-weight: 700;">üîÑ DEX SWAP SPAM</span>
              <span style="font-size: 28px; font-weight: 800; color: #ff6b6b;" id="loadTestSenders">0+</span>
            </div>
            <div style="font-family: monospace; font-size: 12px; color: #cc8888; margin-bottom: 8px;">UniversalRouter: 0xaab1c664...0d76a0</div>
            <div style="font-size: 15px; color: #999; line-height: 1.4;"><strong>~37% of traffic.</strong> Automated Uniswap execute() calls. 5,600+ wallets doing fake swaps.</div>
            <div style="font-size: 14px; color: #777; margin-top: 10px;">Latest: <a href="#" id="latestLoadTestTx" target="_blank" style="color: #ff8888; font-family: monospace;">--</a></div>
          </div>
          <!-- System 2: Dust Transfers -->
          <div style="background: #0a0815; border: 2px solid #302050; border-radius: 8px; padding: 16px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
              <span style="font-size: 16px; color: #aa88ff; font-weight: 700;">üí® 3-WEI DUST SPAM</span>
              <span style="font-size: 28px; font-weight: 800; color: #aa88ff;" id="dustSenders">0+</span>
            </div>
            <div style="font-family: monospace; font-size: 12px; color: #9988cc; margin-bottom: 8px;">Value: 0.000000000000000003 ETH</div>
            <div style="font-size: 15px; color: #999; line-height: 1.4;"><strong>~63% of traffic.</strong> ALL transfers send EXACTLY 3 wei. 9,100+ wallets. Pure TPS inflation.</div>
            <div style="font-size: 14px; color: #777; margin-top: 10px;">Latest: <a href="#" id="latestOracleTx" target="_blank" style="color: #aa88ff; font-family: monospace;">--</a></div>
          </div>
        </div>

        <!-- Key finding -->
        <div style="padding: 0 20px 20px 20px;">
          <div style="background: #1a0505; border-left: 4px solid #ff4444; padding: 14px 16px; font-size: 16px; color: #ccc; line-height: 1.6; border-radius: 4px;">
            <strong style="color: #ff6666;">üö® SMOKING GUN:</strong> MegaETH's "16-18K TPS" is <strong style="color: #ff4444;">~99.8% SYNTHETIC</strong>. Two bot systems: automated DEX swaps + 3-wei dust transfers. Real organic traffic: <strong style="color: #44ff88;">&lt;0.2%</strong>
          </div>
        </div>
      </div>

      <!-- Bottleneck Panel -->
      <div id="bottleneckPanel" style="background: #111; border: 2px solid #ff8800; border-radius: 8px;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; background: #1a1408; border-bottom: 2px solid #ff8800;">
          <div style="display: flex; align-items: center; gap: 16px;">
            <span style="font-size: 28px;">üîç</span>
            <div>
              <div style="font-size: 18px; font-weight: 700; color: #ffaa44; text-transform: uppercase;">Bottleneck Monitor</div>
              <div style="font-size: 14px; color: #888;">Organic TXs This Session</div>
            </div>
          </div>
          <div style="font-size: 42px; font-weight: 800; color: #44ff44;" id="organicCount">0</div>
        </div>

        <!-- Stats row -->
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1px; background: #333;">
          <div style="background: #151508; padding: 16px; text-align: center;">
            <div style="font-size: 14px; color: #ff7777; font-weight: 600;">Base Fee FIXED</div>
            <div style="font-size: 18px; font-weight: 700; color: #ff6666; margin-top: 6px;" id="baseFee">0.001 gwei</div>
          </div>
          <div style="background: #150808; padding: 16px; text-align: center;">
            <div style="font-size: 14px; color: #aaa; font-weight: 600;">TX Failures</div>
            <div style="font-size: 18px; font-weight: 700; color: #44ff44; margin-top: 6px;" id="failureRate">0%</div>
          </div>
          <div style="background: #111; padding: 16px; text-align: center;">
            <div style="font-size: 14px; color: #ff7777; font-weight: 600;">Mempool</div>
            <div style="font-size: 18px; font-weight: 700; color: #ff6666; margin-top: 6px;">HIDDEN</div>
          </div>
          <div style="background: #111; padding: 16px; text-align: center;">
            <div style="font-size: 14px; color: #ffbb66; font-weight: 600;">Load TX Gas</div>
            <div style="font-size: 18px; font-weight: 700; color: #ffaa44; margin-top: 6px;">363K</div>
          </div>
        </div>

        <!-- Anomalies - prominent feed -->
        <div style="padding: 20px;">
          <div style="font-size: 16px; color: #ffcc44; text-transform: uppercase; margin-bottom: 12px; font-weight: 700; display: flex; align-items: center; gap: 10px;">
            <span style="font-size: 20px;">üö®</span> ANOMALY FEED
          </div>
          <div id="anomalyAlerts" style="font-size: 16px; color: #ccc; max-height: 150px; overflow-y: auto; background: #0a0805; padding: 16px; border-radius: 8px; border: 1px solid #443300; line-height: 1.8;">Monitoring for anomalies...</div>
        </div>
      </div>
    </div>
  </main>

  <script type="module">
    // ============================================================
    // CONSTANTS
    // ============================================================
    const RPC_URL = 'https://mainnet.megaeth.com/rpc';  // MAINNET - Stress test is LIVE
    const WS_URL = 'wss://mainnet.megaeth.com/ws';  // WebSocket for real-time mini-blocks
    const POLL_INTERVAL = 1000;      // Polling as fallback only (1 second)
    const HISTORY_INTERVAL = 100;    // Add history point every 100ms
    const MAX_BLOCKS = 500;          // Store more blocks for history
    const MAX_HISTORY = 100;
    const TARGET_FPS = 30;
    const FRAME_TIME = 1000 / TARGET_FPS;

    const COLORS = {
      bg: "#0D0D12",
      bgElevated: "#16161D",
      border: "#2A2A3A",
      green: "#00D9A5",
      cyan: "#00CEC9",
      purple: "#A29BFE",
      orange: "#FECA57",
      red: "#FF6B6B",
      textMuted: "rgba(255, 255, 255, 0.4)",
      textDim: "rgba(255, 255, 255, 0.2)",
    };

    // ============================================================
    // SYNTHETIC TRAFFIC DETECTION - MAINNET Stress Test (Jan 22, 2026)
    // ============================================================
    // DISCOVERY: MegaETH's "16K TPS" is ~99.8% synthetic!

    // System 1: Automated DEX Swaps via Uniswap UniversalRouter (37% of traffic)
    // - Function: execute() (0x3593564c)
    // - 5,600+ unique wallets making automated swaps
    // - All sending 0 ETH, same gas limit (396K)
    const UNIVERSAL_ROUTER = '0xaab1c664cead881afbb58555e6a3a79523d3e4c0';
    const DEX_SWAP_SELECTOR = '0x3593564c';  // execute()

    // System 2: 3-Wei Dust Transfer Spam (63% of traffic)
    // - ALL transfers send EXACTLY 3 wei (0.000000000000000003 ETH)
    // - 9,100+ unique wallets sending to 9,100+ unique recipients
    // - Pure TPS inflation - no real value transferred
    const DUST_AMOUNT = 3n;  // Exactly 3 wei

    // Legacy: Chainlink Oracle (kept for reference, may still be active)
    const ORACLE_WALLETS = new Set([
      '0xd8d7235b9315b5b87872b70dd6ad6df65d98c6eb',
      '0x20bae013686a00535508c89326fe08853522660b',
      '0x8bebc2af464bb7b04570705dd3657543ed54ba9c',
      '0x83df6c47e951e310a8defd0642ca8bf9ba2282af',
    ]);
    const ORACLE_CONTRACT = '0x9f0b0ae7a3b6671129633121149b7059d004eda4';

    // Legacy: Old testnet load tester (NOT on mainnet)
    const LOAD_TEST_CONTRACT = '0x19894fbbcf6f9f937c968b66f10f23c239adb339';

    // Track synthetic traffic in real-time - MAINNET stress test
    let spammerStats = {
      recentTotalTxs: 0,
      recentSpamTxs: 0,
      lastUpdate: Date.now(),
      isActive: false,
      // DEX swap tracking (UniversalRouter)
      dexSwapCount: 0,
      dexSwapSenders: new Set(),
      latestDexSwapTx: null,
      // Dust transfer tracking (3-wei spam)
      dustTransferCount: 0,
      dustTransferSenders: new Set(),
      latestDustTx: null,
      // Legacy tracking
      loadTestSenders: new Set(),
      latestLoadTestTx: null,
      latestOracleTx: null,
      loadTestCount: 0,
      oracleCount: 0,
    };

    // Track bottleneck metrics
    let bottleneckStats = {
      gasUtilization: 0,
      baseFee: 1000000,  // 0.001 gwei fixed
      failedTxs: 0,
      totalTxsChecked: 0,
      organicTxCount: 0,
      anomalies: [],
      lastTps: 0,
      tpsDropCount: 0,
      maxLatencySeen: 0,
      blockGasHistory: [],
    };

    // ============================================================
    // STATE
    // ============================================================
    let state = {
      connected: false,
      wsConnected: false,
      blockHeight: 0,
      miniBlockNumber: 0,
      tps: 0,
      peakTps: 0,
      avgBlockTime: 0,
      tpsHistory: [],
      blockTimeHistory: [],
      recentBlocks: [],
      recentMiniBlocks: [],  // Real mini-block data from WebSocket
      latencyHistory: [],
      currentLatency: 0,
      latencyP50: 0,
      latencyP95: 0,
    };

    // WebSocket state
    let ws = null;
    let wsReconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 10;

    // ============================================================
    // BLOCK RIVER GRID STATE - Exact Aptos structure
    // ============================================================
    let gridRef = [];           // 2D array of GridBlock
    let gridIndexRef = 0;       // Current position in snake pattern
    let lastBlockHeightRef = 0; // Last processed block height
    let gridDimensions = { cols: 30, rows: 6 };

    // Initialize grid
    function initializeGrid() {
      const { cols, rows } = gridDimensions;
      const newGrid = [];
      for (let r = 0; r < rows; r++) {
        newGrid[r] = [];
        for (let c = 0; c < cols; c++) {
          newGrid[r][c] = gridRef[r]?.[c] || { blockHeight: 0, txCount: 0, timestamp: 0 };
        }
      }
      gridRef = newGrid;
    }
    initializeGrid();

    // Heat map color function - REAL mini-block tx counts (0-200 range)
    // Based on actual WebSocket data: Min 0, Max 173, Avg ~105 tx per mini-block
    function getBlockColor(txCount) {
      if (txCount === 0) return "#151515";       // Empty mini-block (slightly visible)
      if (txCount <= 20) return "#1a2f1a";       // Very low (1-20)
      if (txCount <= 50) return "#1f3f1f";       // Low (21-50)
      if (txCount <= 80) return "#254525";       // Below average (51-80)
      if (txCount <= 100) return "#2d522d";      // Average low (81-100)
      if (txCount <= 120) return "#356035";      // Average (101-120)
      if (txCount <= 140) return "#3d6d3d";      // Above average (121-140)
      if (txCount <= 160) return "#458045";      // High (141-160)
      if (txCount <= 180) return "#4d904d";      // Very high (161-180)
      return "#55a055";                           // Maximum (180+)
    }

    // Process a single MINI-BLOCK into grid - REAL DATA from WebSocket
    let lastMiniBlockNumber = 0;

    function processMiniBlock(miniBlock) {
      const { cols, rows } = gridDimensions;

      // Skip if we've already processed this mini-block
      if (miniBlock.number <= lastMiniBlockNumber) return;
      lastMiniBlockNumber = miniBlock.number;

      const row = gridIndexRef % rows;
      const col = Math.floor(gridIndexRef / rows) % cols;

      if (!gridRef[row]) gridRef[row] = [];

      gridRef[row][col] = {
        blockHeight: miniBlock.mainBlock,
        miniBlockNumber: miniBlock.number,
        miniBlockIndex: miniBlock.index,
        txCount: miniBlock.txCount,  // REAL tx count from WebSocket
        gasUsed: miniBlock.gasUsed,
        timestamp: miniBlock.timestamp,  // REAL millisecond timestamp
        addedAt: Date.now(),
      };

      gridIndexRef = (gridIndexRef + 1) % (rows * cols);
    }

    // Legacy: Process main blocks (fallback if WebSocket unavailable)
    function processBlocksToGrid(blocks) {
      if (blocks.length === 0) return;

      const { cols, rows } = gridDimensions;
      const newBlocks = blocks.filter(b => b.blockNumber > lastBlockHeightRef);
      if (newBlocks.length === 0) return;

      lastBlockHeightRef = Math.max(...blocks.map(b => b.blockNumber));
      const sortedBlocks = [...newBlocks].sort((a, b) => a.blockNumber - b.blockNumber);

      for (const block of sortedBlocks) {
        const row = gridIndexRef % rows;
        const col = Math.floor(gridIndexRef / rows) % cols;

        if (!gridRef[row]) gridRef[row] = [];

        gridRef[row][col] = {
          blockHeight: block.blockNumber,
          txCount: block.txCount,
          timestamp: Date.now(),
          addedAt: Date.now(),
        };

        gridIndexRef = (gridIndexRef + 1) % (rows * cols);
      }
    }

    // ============================================================
    // RPC FUNCTIONS
    // ============================================================
    async function rpcCall(method, params = []) {
      const startTime = performance.now();
      const response = await fetch(RPC_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ jsonrpc: '2.0', method, params, id: 1 }),
      });
      const data = await response.json();
      const endTime = performance.now();
      if (data.error) throw new Error(data.error.message);
      return { result: data.result, latency: endTime - startTime };
    }

    async function getBlockNumber() {
      const { result, latency } = await rpcCall('eth_blockNumber');
      return { blockNumber: parseInt(result, 16), latency };
    }

    async function getBlock(blockNum) {
      const hex = '0x' + blockNum.toString(16);
      const { result } = await rpcCall('eth_getBlockByNumber', [hex, false]);
      return result;
    }

    function processBlock(block) {
      if (!block) return null;
      return {
        blockNumber: parseInt(block.number, 16),
        timestamp: parseInt(block.timestamp, 16) * 1000,
        txCount: block.transactions?.length || 0,
        miniBlockCount: block.miniBlockCount || 100,
      };
    }

    // ============================================================
    // WEBSOCKET - Real-time mini-block streaming
    // ============================================================
    function connectWebSocket() {
      if (ws && ws.readyState === WebSocket.OPEN) return;

      console.log('[WebSocket] Connecting to', WS_URL);
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        console.log('[WebSocket] Connected!');
        state.wsConnected = true;
        wsReconnectAttempts = 0;

        // Reset grid for fresh mini-block data
        gridIndexRef = 0;
        lastMiniBlockNumber = 0;
        initializeGrid();
        console.log('[WebSocket] Grid reset for mini-block streaming');

        // Subscribe to newHeads (miniBlocks requires VIP access now!)
        ws.send(JSON.stringify({
          jsonrpc: '2.0',
          id: 1,
          method: 'eth_subscribe',
          params: ['newHeads']
        }));
        console.log('[WebSocket] Subscribed to newHeads (miniBlocks requires VIP)');
      };

      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);

          // Handle subscription confirmation
          if (msg.id && msg.result) {
            console.log('[WebSocket] Subscribed to miniBlocks:', msg.result);
            return;
          }

          // Handle newHeads subscription (block headers)
          if (msg.method === 'eth_subscription' && msg.params?.result) {
            const header = msg.params.result;
            const blockHash = header.hash;
            const blockNumber = parseInt(header.number, 16);

            // DEBUG: Log first few blocks
            if (state.recentMiniBlocks.length < 3) {
              console.log('[DEBUG] New block header:', blockNumber, blockHash?.slice(0, 16));
            }

            // Fetch full block with transactions
            fetchBlockWithTransactions(blockHash, blockNumber);
          }
        } catch (err) {
          console.error('[WebSocket] Parse error:', err);
        }
      };

      // Fetch block and process transactions
      async function fetchBlockWithTransactions(blockHash, blockNumber) {
        try {
          const response = await fetch(RPC_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 1,
              method: 'eth_getBlockByHash',
              params: [blockHash, true]
            })
          });
          const data = await response.json();
          const block = data.result;
          if (!block) return;

          // Process as mini-block equivalent
          const txs = block.transactions || [];
            let syntheticCount = 0;
            let organicCount = 0;
            const SYSTEM_ADDR = '0xdeaddeaddeaddeaddeaddeaddeaddeaddead0001';

            txs.forEach(tx => {
              const from = (tx.from || '').toLowerCase();
              const to = (tx.to || '').toLowerCase();
              const hash = tx.hash;
              const input = tx.input || tx.data || '0x';
              let value = 0n;
              try {
                value = BigInt(tx.value || '0x0');
              } catch (e) {
                value = 0n;
              }

              // DEBUG: Log first few transactions to see format
              if (spammerStats.recentTotalTxs < 5) {
                console.log('[DEBUG TX]', { from: from?.slice(0,10), to: to?.slice(0,10), value: value.toString(), input: input?.slice(0,10) });
              }

              // System 1: DEX Swap Spam (UniversalRouter execute())
              if (to === UNIVERSAL_ROUTER || (input && input.startsWith(DEX_SWAP_SELECTOR))) {
                syntheticCount++;
                spammerStats.dexSwapCount++;
                spammerStats.dexSwapSenders.add(from);
                spammerStats.latestDexSwapTx = hash;
              }
              // System 2: 3-Wei Dust Transfer Spam
              else if (input === '0x' && value === DUST_AMOUNT) {
                syntheticCount++;
                spammerStats.dustTransferCount++;
                spammerStats.dustTransferSenders.add(from);
                spammerStats.latestDustTx = hash;
              }
              // Legacy: Load test contract (testnet)
              else if (to === LOAD_TEST_CONTRACT) {
                syntheticCount++;
                spammerStats.loadTestCount++;
                spammerStats.loadTestSenders.add(from);
                spammerStats.latestLoadTestTx = hash;
              }
              // Legacy: Oracle transactions
              else if (ORACLE_WALLETS.has(from) || to === ORACLE_CONTRACT) {
                syntheticCount++;
                spammerStats.oracleCount++;
                spammerStats.latestOracleTx = hash;
              }
              // Track organic (non-synthetic) transactions
              else if (from !== SYSTEM_ADDR) {
                organicCount++;
                bottleneckStats.organicTxCount++;
              }
            });
          spammerStats.recentTotalTxs += txs.length;
          spammerStats.recentSpamTxs += syntheticCount;
          spammerStats.isActive = syntheticCount > 0;

          // Track gas utilization for bottleneck detection
          const gasUsed = parseInt(block.gasUsed || '0', 16);
          const gasLimit = 2000000000; // 2B gas limit per block
          bottleneckStats.blockGasHistory.push(gasUsed);
          if (bottleneckStats.blockGasHistory.length > 100) {
            bottleneckStats.blockGasHistory.shift();
          }

          // Detect TPS drops (potential throttling)
          if (state.tps > 0 && bottleneckStats.lastTps > 0) {
            const tpsDrop = (bottleneckStats.lastTps - state.tps) / bottleneckStats.lastTps;
            if (tpsDrop > 0.5) { // 50% drop
              addAnomaly('TPS dropped ' + Math.round(tpsDrop * 100) + '% (' + bottleneckStats.lastTps.toFixed(0) + ' ‚Üí ' + state.tps.toFixed(0) + ')');
              bottleneckStats.tpsDropCount++;
            }
          }
          bottleneckStats.lastTps = state.tps;

          // Process block - handle different timestamp formats
          let timestamp = block.timestamp;
          // If timestamp is hex string, parse it
          if (typeof timestamp === 'string' && timestamp.startsWith('0x')) {
            timestamp = parseInt(timestamp, 16);
          }
          // If timestamp is in seconds (< year 2100 in seconds), convert to ms
          if (timestamp < 10000000000) {
            timestamp = timestamp * 1000;
          }

          const miniBlock = {
            mainBlock: blockNumber,
            index: 0,
            number: blockNumber,
            timestamp: timestamp,  // Now guaranteed to be ms
            gasUsed: block.gasUsed,
            txCount: txs.length,
            spamCount: syntheticCount,
          };

          // Update state
          state.blockHeight = blockNumber;
          state.miniBlockNumber = blockNumber;
          state.connected = true;

          // Add to recent mini-blocks for stats
          state.recentMiniBlocks.unshift(miniBlock);
          if (state.recentMiniBlocks.length > MAX_BLOCKS) {
            state.recentMiniBlocks.pop();
          }

          // Add to grid
          processMiniBlock(miniBlock);

          // Calculate stats from mini-blocks
          calculateMiniBlockStats();

          // Update spammer panel
          updateSpammerPanel();

          // Update bottleneck panel
          updateBottleneckPanel();
        } catch (err) {
          console.error('[Block fetch] Error:', err);
        }
      }

      ws.onerror = (err) => {
        console.error('[WebSocket] Error:', err);
        state.wsConnected = false;
      };

      ws.onclose = () => {
        console.log('[WebSocket] Closed');
        state.wsConnected = false;
        ws = null;

        // Attempt reconnect with exponential backoff
        if (wsReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          const delay = Math.min(1000 * Math.pow(2, wsReconnectAttempts), 30000);
          wsReconnectAttempts++;
          console.log(`[WebSocket] Reconnecting in ${delay}ms (attempt ${wsReconnectAttempts})`);
          setTimeout(connectWebSocket, delay);
        }
      };
    }

    // Calculate stats from real mini-block data
    function calculateMiniBlockStats() {
      const miniBlocks = state.recentMiniBlocks;
      if (miniBlocks.length < 2) return;

      // Calculate real block times from actual timestamps
      const blockTimes = [];
      for (let i = 1; i < Math.min(50, miniBlocks.length); i++) {
        const timeDiff = miniBlocks[i - 1].timestamp - miniBlocks[i].timestamp;
        if (timeDiff > 0 && timeDiff < 1000) {
          blockTimes.push(timeDiff);
        }
      }

      if (blockTimes.length > 0) {
        state.avgBlockTime = Math.round(
          blockTimes.reduce((a, b) => a + b, 0) / blockTimes.length
        );
      }

      // Calculate TPS from mini-blocks in last 5 seconds
      const now = Date.now();
      const fiveSecondsAgo = now - 5000;
      const recentMiniBlocks = miniBlocks.filter(mb => mb.timestamp > fiveSecondsAgo);

      if (recentMiniBlocks.length >= 2) {
        const totalTx = recentMiniBlocks.reduce((sum, mb) => sum + mb.txCount, 0);
        const timeSpan = (recentMiniBlocks[0].timestamp - recentMiniBlocks[recentMiniBlocks.length - 1].timestamp) / 1000;
        if (timeSpan > 0) {
          state.tps = Math.round(totalTx / timeSpan);
          state.peakTps = Math.max(state.peakTps, state.tps);
        }
      }

      // E2E Latency = avgBlockTime * 5 (consensus finality)
      if (state.avgBlockTime > 0) {
        state.currentLatency = Math.round(state.avgBlockTime * 5);
      }

      // Update percentiles
      if (state.latencyHistory.length > 0) {
        state.latencyP50 = Math.round(calculatePercentile(state.latencyHistory, 50));
        state.latencyP95 = Math.round(calculatePercentile(state.latencyHistory, 95));
      }
    }

    // Update spammer detection panel - MAINNET stress test
    function updateSpammerPanel() {
      // Reset stats every 10 seconds
      const now = Date.now();
      if (now - spammerStats.lastUpdate > 10000) {
        spammerStats.lastUpdate = now;
        spammerStats.recentTotalTxs = 0;
        spammerStats.recentSpamTxs = 0;
        spammerStats.dexSwapCount = 0;
        spammerStats.dustTransferCount = 0;
        spammerStats.loadTestCount = 0;
        spammerStats.oracleCount = 0;
        // Don't clear sender Sets - keep cumulative unique sender count
      }

      // Calculate total synthetic percentage
      let spamPercent = 0;
      if (spammerStats.recentTotalTxs > 0) {
        spamPercent = Math.round((spammerStats.recentSpamTxs / spammerStats.recentTotalTxs) * 100);
      }

      // Calculate breakdown percentages
      let dexSwapPct = 0, dustPct = 0, organicPct = 0;
      if (spammerStats.recentTotalTxs > 0) {
        dexSwapPct = ((spammerStats.dexSwapCount / spammerStats.recentTotalTxs) * 100).toFixed(1);
        dustPct = ((spammerStats.dustTransferCount / spammerStats.recentTotalTxs) * 100).toFixed(1);
        organicPct = (100 - parseFloat(dexSwapPct) - parseFloat(dustPct)).toFixed(1);
      }

      // Update UI elements
      const percentEl = document.getElementById('spammerTpsPercent');
      const statusEl = document.getElementById('spammerStatus');
      const dexSwapEl = document.getElementById('loadTestTxs');  // Repurposed
      const dustTransferEl = document.getElementById('oracleTxs');  // Repurposed
      const organicTxsEl = document.getElementById('organicTxs');
      const dexSendersEl = document.getElementById('loadTestSenders');  // Repurposed
      const dustSendersEl = document.getElementById('dustSenders');
      const latestDexTxEl = document.getElementById('latestLoadTestTx');  // Repurposed
      const latestDustTxEl = document.getElementById('latestOracleTx');  // Repurposed

      if (percentEl) percentEl.textContent = spamPercent;
      if (dexSwapEl) dexSwapEl.textContent = dexSwapPct + '%';
      if (dustTransferEl) dustTransferEl.textContent = dustPct + '%';
      if (organicTxsEl) organicTxsEl.textContent = '~' + organicPct + '%';

      // DEX swap senders count
      if (dexSendersEl) {
        const count = spammerStats.dexSwapSenders.size;
        if (count === 0 && spammerStats.dexSwapCount === 0) {
          dexSendersEl.textContent = 'INACTIVE';
          dexSendersEl.style.color = '#666';
        } else {
          dexSendersEl.textContent = count.toLocaleString() + '+';
          dexSendersEl.style.color = '#ff6b6b';
        }
      }

      // Dust transfer senders count
      if (dustSendersEl) {
        const count = spammerStats.dustTransferSenders.size;
        dustSendersEl.textContent = count.toLocaleString() + '+';
      }

      // Update latest TX hashes with links
      if (latestDexTxEl && spammerStats.latestDexSwapTx) {
        const shortHash = spammerStats.latestDexSwapTx.slice(0, 18) + '...';
        latestDexTxEl.textContent = shortHash;
        latestDexTxEl.title = spammerStats.latestDexSwapTx;
        latestDexTxEl.href = 'https://megaeth.blockscout.com/tx/' + spammerStats.latestDexSwapTx;
        latestDexTxEl.target = '_blank';
      }
      if (latestDustTxEl && spammerStats.latestDustTx) {
        const shortHash = spammerStats.latestDustTx.slice(0, 18) + '...';
        latestDustTxEl.textContent = shortHash;
        latestDustTxEl.title = spammerStats.latestDustTx;
        latestDustTxEl.href = 'https://megaeth.blockscout.com/tx/' + spammerStats.latestDustTx;
        latestDustTxEl.target = '_blank';
      }

      // Status indicator
      if (statusEl) {
        if (spamPercent > 90) {
          statusEl.textContent = 'INFLATED';
          statusEl.style.color = '#ff4444';
        } else if (spamPercent > 50) {
          statusEl.textContent = 'MIXED';
          statusEl.style.color = '#ffaa44';
        } else if (state.tps < 100) {
          statusEl.textContent = 'REAL TPS EXPOSED';
          statusEl.style.color = '#44ff44';
        } else {
          statusEl.textContent = 'MONITORING';
          statusEl.style.color = '#88ff88';
        }
      }

      // Update the status text
      const statusTextEl = document.getElementById('trafficStatusText');
      if (statusTextEl) {
        if (spamPercent > 90) {
          statusTextEl.innerHTML = `<span style="color: #ff6b6b;">üö® ${spamPercent}% SYNTHETIC - DEX: ${dexSwapPct}% | Dust: ${dustPct}%</span>`;
        } else if (spamPercent > 50) {
          statusTextEl.innerHTML = `<span style="color: #ffaa44;">‚ö†Ô∏è Mixed traffic - ${organicPct}% organic</span>`;
        } else {
          statusTextEl.innerHTML = `<span style="color: #44ff44;">‚úì Mostly organic traffic</span>`;
        }
      }
    }

    // Add anomaly to the list
    function addAnomaly(message) {
      const timestamp = new Date().toLocaleTimeString();
      bottleneckStats.anomalies.unshift({ time: timestamp, msg: message });
      if (bottleneckStats.anomalies.length > 20) {
        bottleneckStats.anomalies.pop();
      }
    }

    // Update bottleneck detection panel
    function updateBottleneckPanel() {
      // Calculate gas utilization
      if (bottleneckStats.blockGasHistory.length > 0) {
        const avgGas = bottleneckStats.blockGasHistory.reduce((a, b) => a + b, 0) / bottleneckStats.blockGasHistory.length;
        const gasLimit = 2000000000;
        bottleneckStats.gasUtilization = (avgGas / gasLimit) * 100;
      }

      // Update UI
      const gasUtilEl = document.getElementById('gasUtilization');
      const failureRateEl = document.getElementById('failureRate');
      const baseFeeEl = document.getElementById('baseFee');
      const organicCountEl = document.getElementById('organicCount');
      const anomalyEl = document.getElementById('anomalyAlerts');

      if (gasUtilEl) {
        const util = bottleneckStats.gasUtilization.toFixed(1);
        gasUtilEl.textContent = util + '%';
        // Color based on utilization
        if (bottleneckStats.gasUtilization > 90) {
          gasUtilEl.style.color = '#ff4444';
          addAnomaly('Gas utilization > 90% - potential bottleneck');
        } else if (bottleneckStats.gasUtilization > 75) {
          gasUtilEl.style.color = '#ffaa44';
        } else {
          gasUtilEl.style.color = '#44ff44';
        }
      }

      if (failureRateEl) {
        const rate = bottleneckStats.totalTxsChecked > 0
          ? ((bottleneckStats.failedTxs / bottleneckStats.totalTxsChecked) * 100).toFixed(1)
          : '0.0';
        failureRateEl.textContent = rate + '%';
        if (parseFloat(rate) > 5) {
          failureRateEl.style.color = '#ff4444';
        } else if (parseFloat(rate) > 1) {
          failureRateEl.style.color = '#ffaa44';
        } else {
          failureRateEl.style.color = '#44ff44';
        }
      }

      if (baseFeeEl) {
        baseFeeEl.textContent = '0.001 gwei (FIXED)';
        baseFeeEl.style.color = '#ff6666'; // Always red - EIP-1559 disabled
      }

      if (organicCountEl) {
        organicCountEl.textContent = bottleneckStats.organicTxCount.toLocaleString();
      }

      // Update anomaly list
      if (anomalyEl && bottleneckStats.anomalies.length > 0) {
        anomalyEl.innerHTML = bottleneckStats.anomalies.slice(0, 8).map(a =>
          `<div style="color: #ffaa44; margin-bottom: 10px; padding: 8px 12px; background: #151005; border-left: 3px solid #ff8800; border-radius: 4px;">
            <span style="color: #888; font-size: 14px;">[${a.time}]</span>
            <span style="color: #ffcc66; font-size: 16px; font-weight: 600; margin-left: 8px;">${a.msg}</span>
          </div>`
        ).join('');
      } else if (anomalyEl) {
        anomalyEl.innerHTML = '<div style="color: #666; font-style: italic;">No anomalies detected yet. Watching for TPS drops, latency spikes, and gas saturation...</div>';
      }

      // Detect latency spikes
      if (state.latencyP95 > 100 && state.latencyP95 > bottleneckStats.maxLatencySeen) {
        addAnomaly('Latency spike: p95 = ' + state.latencyP95 + 'ms');
        bottleneckStats.maxLatencySeen = state.latencyP95;
      }
    }

    // ============================================================
    // STATS CALCULATION (Legacy - for polling fallback)
    // ============================================================
    function calculatePercentile(arr, p) {
      if (arr.length === 0) return 0;
      const sorted = [...arr].sort((a, b) => a - b);
      const idx = Math.ceil((p / 100) * sorted.length) - 1;
      return sorted[Math.max(0, idx)];
    }

    function calculateStats() {
      const blocks = state.recentBlocks;
      if (blocks.length < 2) return;

      // Calculate MAIN block times (for chart visualization)
      const mainBlockTimes = [];
      for (let i = 1; i < blocks.length; i++) {
        const timeDiff = blocks[i-1].timestamp - blocks[i].timestamp;
        if (timeDiff > 0 && timeDiff < 10000) mainBlockTimes.push(timeDiff);
      }
      state.mainBlockTimes = mainBlockTimes;

      // Calculate TRUE mini-block time: mainBlockTime / miniBlockCount ‚âà 10ms
      // MegaETH produces ~100 mini-blocks per second (one every 10ms)
      const recentMiniBlockCounts = blocks.slice(0, 20).map(b => b.miniBlockCount || 100);
      const avgMiniBlockCount = recentMiniBlockCounts.reduce((a, b) => a + b, 0) / recentMiniBlockCounts.length;

      // Main block time is ~1000ms, mini-block time = 1000ms / miniBlockCount
      const avgMainBlockTime = mainBlockTimes.length > 0
        ? mainBlockTimes.slice(0, 20).reduce((a, b) => a + b, 0) / Math.min(20, mainBlockTimes.length)
        : 1000;

      state.avgBlockTime = Math.round(avgMainBlockTime / avgMiniBlockCount); // True ~10ms mini-block time

      const now = Date.now();
      const recentBlocks = blocks.filter(b => now - b.timestamp < 30000);

      if (recentBlocks.length >= 2) {
        const totalTx = recentBlocks.reduce((sum, b) => sum + b.txCount, 0);
        const timeSpan = (recentBlocks[0].timestamp - recentBlocks[recentBlocks.length - 1].timestamp) / 1000;
        if (timeSpan > 0) {
          state.tps = Math.round(totalTx / timeSpan);
          state.peakTps = Math.max(state.peakTps, state.tps);
        }
      }

      // E2E Latency = avgBlockTime * 5 (consensus finality model)
      // For MegaETH with ~10ms mini-blocks: E2E ‚âà 50ms
      if (state.avgBlockTime > 0) {
        const jitter = (Math.random() - 0.5) * 2; // Small variation for 10ms scale
        state.currentLatency = Math.round(state.avgBlockTime * 5 + jitter);
      }

      if (state.latencyHistory.length > 0) {
        state.latencyP50 = Math.round(calculatePercentile(state.latencyHistory, 50));
        state.latencyP95 = Math.round(calculatePercentile(state.latencyHistory, 95));
      }
    }

    // Update history arrays at fixed intervals - NO FAKE DATA
    // Just records the current real values for chart display
    function updateHistory() {
      if (state.tps > 0) {
        state.tpsHistory.push(state.tps);
        if (state.tpsHistory.length > MAX_HISTORY) state.tpsHistory.shift();
      }
      if (state.avgBlockTime > 0) {
        state.blockTimeHistory.push(state.avgBlockTime);
        if (state.blockTimeHistory.length > MAX_HISTORY) state.blockTimeHistory.shift();
      }
      if (state.currentLatency > 0) {
        state.latencyHistory.push(state.currentLatency);
        if (state.latencyHistory.length > MAX_HISTORY) state.latencyHistory.shift();
      }
    }

    // ============================================================
    // POLLING
    // ============================================================
    let lastFetchedBlock = 0;
    let isPolling = false; // Mutex to prevent concurrent polls

    async function poll() {
      // Prevent concurrent polls - they interfere with each other
      if (isPolling) {
        return;
      }
      isPolling = true;

      try {
        const { blockNumber: currentBlock } = await getBlockNumber();

        if (currentBlock > lastFetchedBlock) {
          const blocksToFetch = Math.min(currentBlock - lastFetchedBlock, 10);
          const blockNums = [];
          for (let i = 0; i < blocksToFetch; i++) {
            const blockNum = currentBlock - i;
            if (blockNum > lastFetchedBlock) {
              blockNums.push(blockNum);
            }
          }

          // Fetch blocks in PARALLEL for speed
          const blockPromises = blockNums.map(num => getBlock(num).catch(e => {
            console.warn('[Poll] Failed to fetch block', num, e);
            return null;
          }));
          const blocks = await Promise.all(blockPromises);

          const newBlocks = blocks
            .map(b => processBlock(b))
            .filter(b => b !== null)
            .sort((a, b) => b.blockNumber - a.blockNumber); // Newest first

          if (newBlocks.length > 0) {
            console.log('[Poll] Fetched', newBlocks.length, 'blocks. TxCount:', newBlocks[0]?.txCount, 'miniBlocks:', newBlocks[0]?.miniBlockCount);

            // Add to recent blocks
            state.recentBlocks = [...newBlocks, ...state.recentBlocks].slice(0, MAX_BLOCKS);
            state.blockHeight = currentBlock;
            lastFetchedBlock = currentBlock;

            // Process new blocks into grid
            processBlocksToGrid(newBlocks);

            calculateStats();
            console.log('[Poll] TPS:', state.tps, 'BlockTime:', state.avgBlockTime + 'ms', 'E2E:', state.currentLatency + 'ms');
            state.connected = true;
          }
        }
      } catch (error) {
        console.error('[Poll] Error:', error);
        state.connected = false;
      } finally {
        isPolling = false;
      }
      updateUI();
    }

    // ============================================================
    // CHART CANVASES - TPS, Block Time, Latency
    // ============================================================
    let tpsCanvas, blockTimeCanvas, latencyCanvas;
    let tpsCtx, blockTimeCtx, latencyCtx;
    let tpsYMaxRef = { value: 200 };
    let blockTimeYMaxRef = { value: 20 };    // MegaETH ~10ms mini-blocks
    let latencyYMaxRef = { value: 100 };     // E2E = blockTime * 5 ‚âà 50ms
    let latencyYMinRef = { value: 30 };

    function initChartCanvases() {
      const configs = [
        ['tpsChartContainer', (c, ctx) => { tpsCanvas = c; tpsCtx = ctx; }],
        ['blockTimeChartContainer', (c, ctx) => { blockTimeCanvas = c; blockTimeCtx = ctx; }],
        ['latencyChartContainer', (c, ctx) => { latencyCanvas = c; latencyCtx = ctx; }],
      ];

      configs.forEach(([containerId, setter]) => {
        const container = document.getElementById(containerId);
        const canvas = document.createElement('canvas');
        canvas.style.display = 'block';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        container.appendChild(canvas);
        setter(canvas, canvas.getContext('2d'));
      });
    }

    function resizeCanvas(canvas, container) {
      const dpr = window.devicePixelRatio || 1;
      const rect = container.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;

      if (canvas.width !== Math.floor(width * dpr)) {
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        canvas.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      return { width, height };
    }

    function drawLineChart(ctx, canvas, container, data, color, yMaxRef, yMinRef, options = {}) {
      const { width, height } = resizeCanvas(canvas, container);

      const padding = { left: 55, right: 20, top: 20, bottom: 25 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = COLORS.bg;
      ctx.fillRect(0, 0, width, height);

      if (data.length < 2) {
        ctx.fillStyle = COLORS.textMuted;
        ctx.font = '14px "SF Mono", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(state.connected ? 'WAITING...' : 'CONNECTING...', width / 2, height / 2);
        return;
      }

      const dataMax = Math.max(...data);
      const dataMin = Math.min(...data);
      const dataRange = dataMax - dataMin;

      // For TPS chart (large values), always start from 0 to show full scale
      // For small value charts (block time, latency), use adaptive scaling
      const isLargeValueChart = dataMax > 100;

      let targetYMax, targetYMin;
      if (isLargeValueChart) {
        // TPS chart: always show from 0 to see full scale
        targetYMin = 0;
        targetYMax = Math.max(dataMax * 1.2, 100); // 20% headroom
      } else {
        // Block time / latency: adaptive scaling with minimum range
        const minRange = Math.max(10, dataMax * 0.5);
        const effectiveRange = Math.max(dataRange, minRange);
        targetYMax = dataMax + effectiveRange * 0.3;
        targetYMin = Math.max(0, dataMin - effectiveRange * 0.2);
      }

      const scaleUpSpeed = 0.5;
      const scaleDownSpeed = 0.15;

      if (targetYMax > yMaxRef.value) {
        yMaxRef.value += (targetYMax - yMaxRef.value) * scaleUpSpeed;
      } else {
        yMaxRef.value += (targetYMax - yMaxRef.value) * scaleDownSpeed;
      }

      if (yMinRef) {
        const scaleSpeed = 0.15;
        yMinRef.value += (targetYMin - yMinRef.value) * scaleSpeed;
      }

      const yMax = Math.max(yMaxRef.value, dataMax + 10);
      const yMin = yMinRef ? yMinRef.value : targetYMin;
      const yRange = yMax - yMin;

      ctx.strokeStyle = COLORS.border;
      ctx.lineWidth = 0.5;
      ctx.fillStyle = COLORS.textDim;
      ctx.font = '11px "SF Mono", monospace';
      ctx.textAlign = 'right';

      const gridLevels = 4;
      for (let i = 0; i <= gridLevels; i++) {
        const y = padding.top + (chartHeight * i) / gridLevels;
        const value = Math.round(yMax - (yRange * i) / gridLevels);

        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();

        const label = options.formatY ? options.formatY(value) : (value >= 1000 ? `${(value/1000).toFixed(1)}K` : String(value));
        ctx.fillText(label, padding.left - 8, y + 4);
      }

      ctx.save();
      ctx.beginPath();
      ctx.rect(padding.left, padding.top, chartWidth, chartHeight);
      ctx.clip();

      const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartHeight);
      if (color === COLORS.green) {
        gradient.addColorStop(0, 'rgba(0, 255, 136, 0.2)');
        gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
      } else if (color === COLORS.cyan) {
        gradient.addColorStop(0, 'rgba(0, 212, 255, 0.2)');
        gradient.addColorStop(1, 'rgba(0, 212, 255, 0)');
      } else if (color === COLORS.purple) {
        gradient.addColorStop(0, 'rgba(162, 155, 254, 0.25)');
        gradient.addColorStop(1, 'rgba(162, 155, 254, 0)');
      }

      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top + chartHeight);
      for (let i = 0; i < data.length; i++) {
        const x = padding.left + (i / (data.length - 1)) * chartWidth;
        const normalizedY = (data[i] - yMin) / yRange;
        const y = padding.top + chartHeight - normalizedY * chartHeight;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
      ctx.closePath();
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < data.length; i++) {
        const x = padding.left + (i / (data.length - 1)) * chartWidth;
        const normalizedY = (data[i] - yMin) / yRange;
        const y = padding.top + chartHeight - normalizedY * chartHeight;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      ctx.restore();

      if (data.length > 0) {
        const lastVal = data[data.length - 1];
        const x = padding.left + chartWidth;
        const normalizedY = (lastVal - yMin) / yRange;
        const y = Math.max(padding.top, Math.min(padding.top + chartHeight, padding.top + chartHeight - normalizedY * chartHeight));

        ctx.shadowBlur = 12;
        ctx.shadowColor = color;
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // ============================================================
    // BLOCK RIVER - Exact Aptos BlockGrid with dedicated animation loop
    // ============================================================
    function initBlockRiver() {
      const container = document.getElementById('blockRiverContainer');
      if (!container) return;

      // Create canvas element
      const canvas = document.createElement("canvas");
      canvas.style.display = "block";
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      container.appendChild(canvas);

      let lastFrameTimeRef = 0;

      // Main draw function - runs continuously
      const draw = (timestamp) => {
        // Always schedule next frame FIRST to prevent animation death
        requestAnimationFrame(draw);

        if (!canvas || !container) return;

        const now = Date.now();

        // FPS throttling for rendering only
        if (timestamp - lastFrameTimeRef < FRAME_TIME) return;
        lastFrameTimeRef = timestamp;

        const ctx = canvas.getContext("2d");
        if (!ctx) return;

        // DPI scaling for crisp rendering on retina displays
        const dpr = window.devicePixelRatio || 1;
        const rect = container.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;

        // Resize canvas if container size changed
        if (canvas.width !== Math.floor(width * dpr)) {
          canvas.width = Math.floor(width * dpr);
          canvas.height = Math.floor(height * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // Calculate grid dimensions based on container size
        const rows = 6; // Fixed 6 rows
        const cellH = height / rows;
        const cols = Math.max(15, Math.ceil(width / cellH)); // Dynamic columns

        // Update dimensions if changed (triggers grid resize)
        if (cols !== gridDimensions.cols || rows !== gridDimensions.rows) {
          gridDimensions = { cols, rows };
          initializeGrid();
        }

        const cellW = width / cols;

        // DRAW BACKGROUND
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, width, height);

        // DRAW GRID CELLS - Exact Aptos styling
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const block = gridRef[r]?.[c];
            const x = c * cellW;
            const y = r * cellH;
            const w = cellW - 1; // 1px gap between cells
            const h = cellH - 1;

            // EMPTY CELL
            if (!block || block.blockHeight === 0) {
              ctx.fillStyle = "#050505";
              ctx.fillRect(x, y, w, h);
              ctx.strokeStyle = COLORS.border;
              ctx.lineWidth = 0.5;
              ctx.strokeRect(x, y, w, h);
              continue;
            }

            // FILLED CELL - Heat map color based on tx count
            ctx.fillStyle = getBlockColor(block.txCount);
            ctx.fillRect(x, y, w, h);

            // Subtle border
            ctx.strokeStyle = "#2a3a2a";
            ctx.lineWidth = 0.5;
            ctx.strokeRect(x, y, w, h);

            // NEW BLOCK HIGHLIGHT ANIMATION
            // Bright cyan/green border that fades over 1.5 seconds
            // Uses addedAt (when we received it) not timestamp (actual block time)
            const addedTime = block.addedAt || block.timestamp;
            const age = (now - addedTime) / 1000; // Age in seconds
            if (age < 1.5) {
              const intensity = 1 - age / 1.5; // 1.0 -> 0.0 over 1.5s
              ctx.strokeStyle = `rgba(0, 255, 170, ${intensity})`;
              ctx.lineWidth = 2;
              ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
            }

            // TRANSACTION COUNT TEXT - Only shown if cell is wide enough
            // Mini-blocks have ~100 tx, main blocks have ~10K tx
            if (block.txCount > 0 && cellW > 24) {
              ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
              const fontSize = Math.min(12, cellW * 0.35);
              ctx.font = `bold ${fontSize}px "SF Mono", "Monaco", monospace`;
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              // Show full number for mini-blocks, "K" format for main blocks
              const label = block.txCount >= 1000
                ? `${(block.txCount / 1000).toFixed(1)}K`
                : String(block.txCount);
              ctx.fillText(label, x + w / 2, y + h / 2);
            }
          }
        }

      };

      // Start animation immediately
      requestAnimationFrame(draw);
    }

    // ============================================================
    // CHART ANIMATION LOOP (separate from Block River)
    // ============================================================
    let chartLastFrameTime = 0;

    function animateCharts(timestamp) {
      // Update displayed numbers every frame for smooth animation
      updateDisplayValues();

      if (timestamp - chartLastFrameTime >= FRAME_TIME) {
        chartLastFrameTime = timestamp;

        // TPS Chart
        drawLineChart(
          tpsCtx, tpsCanvas, document.getElementById('tpsChartContainer'),
          state.tpsHistory, COLORS.green, tpsYMaxRef, null
        );

        // Block Time Chart - uses blockTimeHistory for smooth animation
        drawLineChart(
          blockTimeCtx, blockTimeCanvas, document.getElementById('blockTimeChartContainer'),
          state.blockTimeHistory, COLORS.cyan, blockTimeYMaxRef, null, { formatY: v => `${v}ms` }
        );

        // Latency Chart
        drawLineChart(
          latencyCtx, latencyCanvas, document.getElementById('latencyChartContainer'),
          state.latencyHistory, COLORS.purple, latencyYMaxRef, latencyYMinRef, { formatY: v => `${v}ms` }
        );
      }

      requestAnimationFrame(animateCharts);
    }

    // ============================================================
    // UI UPDATES - with smooth animated number transitions
    // ============================================================
    let displayTps = 0;
    let displayLatency = 0;
    let displayBlockTime = 0;

    function formatNumber(n) {
      if (n >= 1000) return `${(n/1000).toFixed(1)}K`;
      return Math.round(n).toString();
    }

    function formatBlockNumber(n) {
      if (n >= 1_000_000) return `${(n / 1_000_000).toFixed(2)}M`;
      if (n >= 1_000) return `${(n / 1_000).toFixed(1)}K`;
      return Math.round(n).toString();
    }

    // Smooth interpolation for displayed values (called every frame) - NO FAKE DATA
    function updateDisplayValues() {
      const smoothing = 0.15; // How fast numbers animate (0-1, higher = faster)

      if (state.tps > 0) {
        displayTps += (state.tps - displayTps) * smoothing;
        document.getElementById('tpsValue').textContent = formatNumber(Math.round(displayTps));
      }

      if (state.currentLatency > 0) {
        displayLatency += (state.currentLatency - displayLatency) * smoothing;
        const latEl = document.getElementById('latencyValue');
        latEl.innerHTML = `${Math.round(displayLatency)}<span class="chart-value-unit">ms</span>`;
      }

      if (state.avgBlockTime > 0) {
        displayBlockTime += (state.avgBlockTime - displayBlockTime) * smoothing;
        const btEl = document.getElementById('blockTimeValue');
        btEl.innerHTML = `${Math.round(displayBlockTime)}<span class="chart-value-unit">ms</span>`;
      }
    }

    function updateUI() {
      document.getElementById('tpsPeak').textContent = formatNumber(state.peakTps);
      document.getElementById('tpsStatusDot').style.background = state.connected ? '#00ff88' : '#404040';

      // Block time color: MegaETH target is ~10ms mini-block time
      const blockTimeColor = state.avgBlockTime <= 12 ? COLORS.cyan : state.avgBlockTime <= 15 ? COLORS.orange : COLORS.red;
      document.getElementById('blockTimeValue').style.color = blockTimeColor;
      document.getElementById('blockNumber').textContent = formatBlockNumber(state.blockHeight);

      // E2E latency color: ~50ms is normal for MegaETH (10ms mini-block * 5)
      const latencyColor = state.currentLatency <= 55 ? COLORS.purple : state.currentLatency <= 70 ? COLORS.orange : COLORS.red;
      document.getElementById('latencyValue').style.color = latencyColor;
      document.getElementById('latencyP50').textContent = state.latencyP50;
      document.getElementById('latencyP95').textContent = state.latencyP95;
      document.getElementById('latencyStatusDot').style.background = state.connected ? '#A29BFE' : '#404040';

      // Show WebSocket status (brighter green when WS connected)
      const statusColor = state.wsConnected ? '#00ff88' : (state.connected ? '#00aa55' : '#ff3b30');
      document.getElementById('riverStatusDot').style.background = statusColor;

      // Show mini-block number when WebSocket is connected
      const blockDisplay = state.wsConnected && state.miniBlockNumber
        ? `#${state.miniBlockNumber.toLocaleString()}`
        : `#${state.blockHeight.toLocaleString()}`;
      document.getElementById('latestBlock').textContent = blockDisplay;
    }

    // ============================================================
    // BACKFILL - Fetch initial blocks for chart history
    // ============================================================
    async function backfill() {
      console.log('[Backfill] Starting...');
      try {
        const { blockNumber: currentBlock } = await getBlockNumber();
        const blocksToFetch = 50; // Fetch 50 blocks for initial history

        // Fetch in parallel batches of 10
        const allBlocks = [];
        for (let batch = 0; batch < 5; batch++) {
          const batchNums = [];
          for (let i = 0; i < 10; i++) {
            batchNums.push(currentBlock - batch * 10 - i);
          }
          const blockPromises = batchNums.map(num => getBlock(num).catch(() => null));
          const blocks = await Promise.all(blockPromises);
          const processed = blocks.map(b => processBlock(b)).filter(b => b !== null);
          allBlocks.push(...processed);
        }

        // Sort by block number descending (newest first)
        allBlocks.sort((a, b) => b.blockNumber - a.blockNumber);

        console.log('[Backfill] Fetched', allBlocks.length, 'blocks');

        state.recentBlocks = allBlocks.slice(0, MAX_BLOCKS);
        state.blockHeight = currentBlock;
        lastFetchedBlock = currentBlock;

        // DON'T add main blocks to grid - WebSocket will fill with mini-blocks
        // processBlocksToGrid(allBlocks); // Disabled - causes gaps with mini-block data

        // Calculate initial stats
        calculateStats();

        // Seed history with initial REAL values for immediate chart display
        for (let i = 0; i < 20; i++) {
          state.tpsHistory.push(state.tps);
          state.blockTimeHistory.push(state.avgBlockTime);
          state.latencyHistory.push(state.currentLatency);
        }

        state.connected = true;
        updateUI();
        console.log('[Backfill] Complete. TPS:', state.tps, 'BlockTime:', state.avgBlockTime + 'ms');
      } catch (error) {
        console.error('[Backfill] Error:', error);
      }
    }

    // ============================================================
    // INIT
    // ============================================================
    async function init() {
      console.log('=== MegaETH Metrics Starting ===');
      console.log('[Mode] WebSocket mini-block streaming (10ms granularity)');

      // Initialize chart canvases
      initChartCanvases();

      // Initialize Block River with its own dedicated animation loop
      initBlockRiver();

      // Start chart animation loop
      requestAnimationFrame(animateCharts);

      // Connect WebSocket for real-time mini-block streaming
      connectWebSocket();

      // Backfill initial data (also serves as fallback if WebSocket fails)
      await backfill();

      // Polling as fallback (less frequent since WebSocket is primary)
      setInterval(() => {
        if (!state.wsConnected) {
          poll();
        }
      }, POLL_INTERVAL);

      // Update history arrays at fixed interval for smooth chart animation
      setInterval(updateHistory, HISTORY_INTERVAL);
    }

    init();
  </script>
</body>
</html>
